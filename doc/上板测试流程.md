# 矩阵计算器上板测试流程

本文档提供INPUT模式、GENERATE模式和DISPLAY模式的详细上板测试流程，覆盖所有功能点。

---

## 一、INPUT模式测试流程

### 1.1 准备工作

1. **硬件连接**
   - 连接EGO1开发板到PC（USB转串口）
   - 确认串口参数：115200波特率，8数据位，1停止位，无校验
   - 打开串口调试助手（或PC端UI）

2. **初始状态检查**
   - 开发板上电，观察LED状态
   - J3（ERROR）应熄灭
   - J2（BUSY）应熄灭
   - K2（DONE）应熄灭
   - 七段数码管应显示空白或菜单状态

### 1.2 基础功能测试

#### 测试用例1：正常输入2×3矩阵

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `00`（INPUT模式）
   - 其他开关保持默认（0）

2. **进入INPUT模式**
   - 按下按键V1（key[0]，确认键）
   - 观察数码管：应显示 "I"（INPUT模式标识）

3. **通过UART发送矩阵数据**
   - 在串口调试助手发送窗口输入：`2 3 4 5 6 7 8 9`
   - 点击"发送"按钮
   - **数据格式说明**：
     - `2` = 行数m
     - `3` = 列数n
     - `4 5 6 7 8 9` = 矩阵元素（按行优先：A00, A01, A02, A10, A11, A12）

4. **观察系统响应**
   - LED状态：J3应保持熄灭（无错误）
   - 等待1-2秒，系统完成存储

5. **验证存储**
   - 切换到DISPLAY模式验证（见DISPLAY模式测试）

**预期结果：**
- 矩阵成功存储，无错误提示
- 矩阵ID自动分配（通常为0或1）

---

#### 测试用例2：输入3×3矩阵（完整元素）

**步骤：**
1. 保持sw[1:0] = `00`
2. 按下V1确认键（如已在INPUT模式可跳过）
3. 发送UART数据：`3 3 1 2 3 4 5 6 7 8 9`
   - 含义：3×3矩阵，元素1-9
4. 观察LED：J3应熄灭

**预期结果：**
- 9个元素全部存储
- 矩阵格式：第一行[1,2,3]，第二行[4,5,6]，第三行[7,8,9]

---

#### 测试用例3：输入元素不足的情况（自动补0）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`2 3 1 2 3 4`
   - 含义：2×3矩阵（需要6个元素），但只输入4个
3. 观察系统响应

**预期结果：**
- 系统自动将A11和A12补0
- 最终矩阵：第一行[1,2,3]，第二行[4,0,0]
- 无错误提示（符合项目要求）

---

#### 测试用例4：输入元素过多的情况（截断）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`2 3 1 2 3 4 5 6 7 8`
   - 含义：2×3矩阵（需要6个元素），但输入8个
3. 观察系统响应

**预期结果：**
- 系统只取前6个元素：1,2,3,4,5,6
- 第7、8个元素被忽略
- 最终矩阵：第一行[1,2,3]，第二行[4,5,6]

---

### 1.3 错误处理测试

#### 测试用例5：维度超出范围（m>5）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`6 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18`
   - 含义：6×3矩阵（m=6超出1-5范围）

**预期结果：**
- J3（ERROR）LED点亮并闪烁
- 七段数码管显示倒计时（默认10秒，可通过CONFIG COUNT配置）
- 倒计时结束后自动返回菜单
- 矩阵未存储

---

#### 测试用例6：维度超出范围（n>5）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`3 6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18`

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 矩阵未存储

---

#### 测试用例7：元素值超出范围（>9，需先配置范围）

**前置条件：**
- 先通过CONFIG RANGE设置元素范围（见配置测试）

**步骤：**
1. 假设已配置范围[0,9]
2. sw[1:0] = `00`，按下V1
3. 发送：`2 2 1 2 10 4`
   - 含义：2×2矩阵，元素10超出范围

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 矩阵未存储

---

#### 测试用例8：元素值超出范围（<0，负数）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`2 2 -1 2 3 4`
   - 如果系统不支持负数输入，可能解析为其他值

**预期结果：**
- 根据实际实现，可能报错或忽略负号

---

### 1.4 存储覆盖测试

#### 测试用例9：同规格矩阵覆盖（默认每种规格最多2个）

**步骤：**
1. **第一次输入**
   - sw[1:0] = `00`，按下V1
   - 发送：`2 2 1 2 3 4`（矩阵A）

2. **第二次输入（相同规格）**
   - 保持INPUT模式
   - 发送：`2 2 5 6 7 8`（矩阵B，覆盖A）

3. **第三次输入（相同规格）**
   - 发送：`2 2 9 0 1 2`（矩阵C，覆盖B）

**预期结果：**
- 系统最多保存2个2×2矩阵
- 新矩阵覆盖最旧的同规格矩阵
- 可通过DISPLAY模式验证覆盖情况

---

### 1.5 配置相关测试

#### 测试用例10：配置元素范围后输入

**步骤：**
1. **配置元素范围**
   - 在任意模式下，通过UART发送：`CONFIG RANGE 0 15`
   - 等待配置完成

2. **输入矩阵（元素值在0-15范围内）**
   - sw[1:0] = `00`，按下V1
   - 发送：`2 2 10 11 12 13`

**预期结果：**
- 矩阵成功存储
- 元素值10-13在配置范围内，无错误

---

#### 测试用例11：配置每种规格最大数量

**步骤：**
1. **配置最大数量**
   - 发送：`CONFIG MAX 3`
   - 含义：每种规格最多存储3个矩阵

2. **输入多个同规格矩阵**
   - sw[1:0] = `00`，按下V1
   - 连续输入4个2×2矩阵

**预期结果：**
- 前3个矩阵正常存储
   - 第4个矩阵覆盖第1个（如果实现为FIFO覆盖）

---

### 1.6 边界值测试

#### 测试用例12：最小矩阵（1×1）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`1 1 5`

**预期结果：**
- 成功存储1×1矩阵，元素值为5

---

#### 测试用例13：最大矩阵（5×5）

**步骤：**
1. sw[1:0] = `00`，按下V1
2. 发送：`5 5` + 25个元素值（0-9）
   - 例如：`5 5 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4`

**预期结果：**
- 成功存储5×5矩阵（25个元素）

---

### 1.7 模式切换测试

#### 测试用例14：INPUT模式中返回菜单

**步骤：**
1. sw[1:0] = `00`，按下V1进入INPUT模式
2. 按下R17（key[1]，返回键）

**预期结果：**
- 返回主菜单
- 数码管显示空白或菜单标识

---

#### 测试用例15：快速返回菜单

**步骤：**
1. 在INPUT模式下
2. 按下key[3]（快速菜单键，如果实现）

**预期结果：**
- 立即返回主菜单

---

---

## 二、GENERATE模式测试流程

### 2.1 准备工作

1. **硬件连接**（同INPUT模式）
2. **初始状态检查**（同INPUT模式）

### 2.2 基础功能测试

#### 测试用例1：生成1个2×2随机矩阵

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `01`（GENERATE模式）

2. **进入GENERATE模式**
   - 按下按键V1（确认键）
   - 观察数码管：应显示 "G"（GENERATE模式标识）

3. **通过UART发送生成命令**
   - 在串口调试助手发送窗口输入：`2 2 1`
   - 点击"发送"
   - **数据格式说明**：
     - `2` = 行数m
     - `2` = 列数n
     - `1` = 生成矩阵个数

4. **观察系统响应**
   - LED状态：
     - J2（BUSY）应点亮（生成进行中）
     - 生成完成后，K2（DONE）应点亮3秒后熄灭
   - 等待生成完成（通常1-2秒）

5. **验证生成结果**
   - 切换到DISPLAY模式查看生成的矩阵
   - 检查元素值是否在配置范围内（默认0-9）

**预期结果：**
- 成功生成1个2×2随机矩阵
- 矩阵元素值在[0,9]范围内（或配置的范围）
- 矩阵已自动存储

---

#### 测试用例2：生成2个3×3随机矩阵

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`3 3 2`
   - 含义：生成2个3×3矩阵

3. **观察系统响应**
   - J2（BUSY）点亮
   - 等待生成完成（2个矩阵需要更长时间）
   - K2（DONE）点亮

**预期结果：**
- 成功生成2个3×3随机矩阵
- 两个矩阵的元素值不同（随机性验证）
- 两个矩阵都已存储

---

#### 测试用例3：生成多个矩阵（测试随机性）

**步骤：**
1. sw[1:0] = `01`，按下V1
2. **第一次生成**
   - 发送：`2 2 1`
   - 记录生成的矩阵元素值

3. **第二次生成（相同规格）**
   - 发送：`2 2 1`
   - 记录生成的矩阵元素值

**预期结果：**
- 两次生成的矩阵元素值**不同**（验证随机性）
- 如果相同，说明随机数生成器有问题（不得分）

---

### 2.3 配置范围测试

#### 测试用例4：配置元素范围后生成

**步骤：**
1. **配置元素范围**
   - 发送：`CONFIG RANGE 5 9`
   - 等待配置完成

2. **生成矩阵**
   - sw[1:0] = `01`，按下V1
   - 发送：`3 3 1`

**预期结果：**
- 生成的矩阵元素值全部在[5,9]范围内
- 无元素值小于5或大于9

---

#### 测试用例5：配置负数范围（如果支持）

**步骤：**
1. **配置负数范围**
   - 发送：`CONFIG RANGE -3 3`
   - 等待配置完成

2. **生成矩阵**
   - sw[1:0] = `01`，按下V1
   - 发送：`2 2 1`

**预期结果：**
- 生成的矩阵元素值在[-3,3]范围内
- 可能包含负数（根据实际实现）

---

### 2.4 边界值测试

#### 测试用例6：生成最小矩阵（1×1）

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`1 1 1`

**预期结果：**
- 成功生成1×1随机矩阵
- 元素值在配置范围内

---

#### 测试用例7：生成最大矩阵（5×5）

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`5 5 1`

**预期结果：**
- 成功生成5×5随机矩阵（25个元素）
- 所有元素值在配置范围内

---

#### 测试用例8：生成最大数量矩阵

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`2 2 2`（假设默认每种规格最多2个）

**预期结果：**
- 成功生成2个2×2矩阵
- 如果已存在同规格矩阵，可能被覆盖

---

### 2.5 错误处理测试

#### 测试用例9：维度超出范围

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`6 3 1`（m=6超出范围）

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 未生成矩阵

---

#### 测试用例10：生成数量超出限制

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`2 2 10`（生成10个，可能超出存储限制）

**预期结果：**
- 根据实现，可能：
  - 只生成允许的最大数量
  - 或报错

---

### 2.6 生成后显示测试

#### 测试用例11：生成后自动显示（如果实现）

**步骤：**
1. sw[1:0] = `01`，按下V1
2. 发送：`2 2 1`
3. 等待生成完成

**预期结果：**
- 如果系统实现自动显示，UART应输出生成的矩阵
- 格式：清晰的矩阵展示（元素间空格，行间换行）

---

### 2.7 模式切换测试

#### 测试用例12：GENERATE模式中返回菜单

**步骤：**
1. sw[1:0] = `01`，按下V1进入GENERATE模式
2. 按下R17（返回键）

**预期结果：**
- 返回主菜单
- 如果正在生成，可能中断或完成后再返回

---

---

## 三、DISPLAY模式测试流程

### 3.1 准备工作

1. **前置条件**
   - 确保已通过INPUT或GENERATE模式存储了至少1个矩阵
   - 建议准备多个不同规格的矩阵用于测试

2. **硬件连接**（同前）

### 3.2 基础功能测试

#### 测试用例1：显示单个矩阵

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `10`（DISPLAY模式）

2. **进入DISPLAY模式**
   - 按下按键V1（确认键）
   - 观察数码管：应显示当前矩阵编号（如"0"）

3. **观察UART输出**
   - 串口调试助手接收窗口应显示矩阵
   - **预期格式示例**（2×3矩阵）：
     ```
     Matrix 0 (2x3):
     4 5 6
     7 8 9
     ```
   - 或简化格式：
     ```
     4 5 6
     7 8 9
     ```

**预期结果：**
- UART清晰显示矩阵内容
- 元素间有空格分隔
- 行间有换行
- 数码管显示矩阵编号

---

#### 测试用例2：浏览下一个矩阵

**步骤：**
1. sw[1:0] = `10`，按下V1进入DISPLAY模式
2. 观察当前显示的矩阵编号（数码管）
3. **按下R11（key[2]，下一个键）**
4. 观察UART输出和数码管

**预期结果：**
- 数码管显示的矩阵编号递增（如0→1）
- UART显示下一个矩阵的内容
- 如果到达最后一个矩阵，可能循环回0或停止

---

#### 测试用例3：显示空槽位（如果存在）

**步骤：**
1. sw[1:0] = `10`，按下V1
2. 连续按下R11，浏览所有矩阵槽位

**预期结果：**
- 如果某个槽位为空，UART可能显示：
  - "Empty"
  - 或空白
  - 或错误提示
- 数码管仍显示槽位编号

---

### 3.3 不同规格矩阵显示测试

#### 测试用例4：显示1×1矩阵

**步骤：**
1. 确保已存储1×1矩阵
2. sw[1:0] = `10`，按下V1
3. 浏览到该矩阵

**预期结果：**
- UART显示：
  ```
  Matrix X (1x1):
  5
  ```
- 格式清晰

---

#### 测试用例5：显示5×5矩阵

**步骤：**
1. 确保已存储5×5矩阵
2. sw[1:0] = `10`，按下V1
3. 浏览到该矩阵

**预期结果：**
- UART显示完整的5×5矩阵
- 5行，每行5个元素
- 格式清晰，易于阅读

---

#### 测试用例6：显示不同规格矩阵序列

**步骤：**
1. 确保已存储多个不同规格矩阵：
   - 1×1矩阵
   - 2×3矩阵
   - 3×3矩阵
   - 5×2矩阵
2. sw[1:0] = `10`，按下V1
3. 连续按下R11，浏览所有矩阵

**预期结果：**
- 每个矩阵都能正确显示
- 矩阵编号正确对应
- 格式清晰，不会混淆

---

### 3.4 显示格式验证

#### 测试用例7：验证显示格式清晰度

**步骤：**
1. sw[1:0] = `10`，按下V1
2. 显示一个2×3矩阵

**预期结果：**
- **格式要求**（根据项目文档）：
  - 元素之间以空格分隔
  - 行之间以换行分隔
  - 可选的标题行（如"Matrix 0 (2x3):"）
- **示例**：
  ```
  Matrix 0 (2x3):
  4 5 6
  7 8 9
  ```
  或
  ```
  4 5 6
  7 8 9
  ```

---

#### 测试用例8：显示多个矩阵（如果支持）

**步骤：**
1. sw[1:0] = `10`，按下V1
2. 如果系统支持一次显示多个矩阵，观察输出

**预期结果：**
- 多个矩阵从上到下依次显示
- 矩阵之间有明确分隔（空行或标识）

---

### 3.5 边界情况测试

#### 测试用例9：无矩阵可显示

**步骤：**
1. **清空所有矩阵**（如果可能，或使用全新系统）
2. sw[1:0] = `10`，按下V1

**预期结果：**
- 可能显示：
  - "No matrices available"
  - 或空白
  - 或错误提示
- 数码管可能显示0或空白

---

#### 测试用例10：显示刚生成的矩阵

**步骤：**
1. **在GENERATE模式下生成矩阵**
   - sw[1:0] = `01`，按下V1
   - 发送：`2 2 1`
   - 等待生成完成

2. **立即切换到DISPLAY模式**
   - sw[1:0] = `10`，按下V1

**预期结果：**
- 能正确显示刚生成的矩阵
- 矩阵内容与生成的一致

---

#### 测试用例11：显示运算结果矩阵

**步骤：**
1. **执行一次矩阵运算**（在OPERATION模式下）
   - 例如：矩阵加法
   - 运算结果自动存储

2. **切换到DISPLAY模式**
   - sw[1:0] = `10`，按下V1
   - 浏览到结果矩阵

**预期结果：**
- 能正确显示运算结果
- 结果矩阵的维度正确
- 元素值正确

---

### 3.6 模式切换测试

#### 测试用例12：DISPLAY模式中返回菜单

**步骤：**
1. sw[1:0] = `10`，按下V1进入DISPLAY模式
2. 按下R17（返回键）

**预期结果：**
- 返回主菜单
- 数码管显示菜单状态

---

#### 测试用例13：快速返回菜单

**步骤：**
1. 在DISPLAY模式下
2. 按下key[3]（如果实现快速菜单键）

**预期结果：**
- 立即返回主菜单

---

### 3.7 实时更新测试

#### 测试用例14：显示后修改矩阵（如果可能）

**步骤：**
1. sw[1:0] = `10`，按下V1，显示矩阵0
2. **切换到INPUT模式，覆盖矩阵0**
   - sw[1:0] = `00`，按下V1
   - 发送相同规格的新矩阵数据

3. **切换回DISPLAY模式**
   - sw[1:0] = `10`，按下V1

**预期结果：**
- 显示更新后的矩阵内容
- 旧内容已被新内容覆盖

---

---

## 四、通用测试项

### 4.1 配置命令测试（所有模式通用）

#### 测试用例：CONFIG RANGE

**步骤：**
1. 在任意模式下（或菜单模式）
2. 通过UART发送：`CONFIG RANGE 0 15`
3. 观察系统响应

**预期结果：**
- 配置成功（可能无显式提示，或LED指示）
- 后续INPUT/GENERATE模式使用新范围

---

#### 测试用例：CONFIG MAX

**步骤：**
1. 发送：`CONFIG MAX 3`
2. 验证存储限制是否更新

**预期结果：**
- 每种规格最多存储数量更新为3

---

#### 测试用例：CONFIG COUNT（倒计时）

**步骤：**
1. 发送：`CONFIG COUNT 15`
2. 触发一个错误（如维度超范围）

**预期结果：**
- 错误倒计时显示15秒（而非默认10秒）

---

### 4.2 LED和数码管综合测试

#### 测试用例：状态指示完整性

**测试场景：**
1. **正常操作**
   - J3（ERROR）熄灭
   - J2（BUSY）在运算/生成时点亮
   - K2（DONE）在完成时点亮3秒

2. **错误情况**
   - J3（ERROR）闪烁
   - 数码管显示倒计时

3. **模式指示**
   - INPUT模式：显示"I"
   - GENERATE模式：显示"G"
   - DISPLAY模式：显示矩阵编号

---

### 4.3 串口通信稳定性测试

#### 测试用例：连续操作

**步骤：**
1. 连续执行多个操作：
   - INPUT → DISPLAY → GENERATE → DISPLAY
2. 观察UART通信是否稳定

**预期结果：**
- 无数据丢失
- 无通信错误
- 响应及时

---

## 五、测试检查清单

### INPUT模式检查清单
- [ ] 正常输入各种规格矩阵（1×1到5×5）
- [ ] 元素不足自动补0
- [ ] 元素过多自动截断
- [ ] 维度超范围报错
- [ ] 元素值超范围报错
- [ ] 同规格矩阵覆盖功能
- [ ] 配置范围后输入
- [ ] 模式切换正常

### GENERATE模式检查清单
- [ ] 生成单个矩阵
- [ ] 生成多个矩阵
- [ ] 随机性验证（相同输入生成不同结果）
- [ ] 配置范围后生成
- [ ] 边界值测试（1×1，5×5）
- [ ] 维度超范围报错
- [ ] 生成后存储验证

### DISPLAY模式检查清单
- [ ] 单个矩阵显示清晰
- [ ] 浏览下一个矩阵
- [ ] 不同规格矩阵正确显示
- [ ] 显示格式符合要求（空格、换行）
- [ ] 空槽位处理
- [ ] 显示刚生成的矩阵
- [ ] 显示运算结果
- [ ] 模式切换正常

### 通用检查清单
- [ ] LED状态指示正确
- [ ] 数码管显示正确
- [ ] UART通信稳定
- [ ] 配置命令生效
- [ ] 错误处理完善
- [ ] 倒计时功能正常

---

## 六、常见问题排查

### 问题1：UART无响应
- 检查串口参数（115200,8N1）
- 检查硬件连接
- 检查开发板是否正常运行

### 问题2：矩阵未存储
- 检查维度是否在1-5范围内
- 检查元素值是否在配置范围内
- 检查LED错误指示

### 问题3：显示格式混乱
- 检查UART接收窗口设置
- 检查换行符处理
- 检查元素分隔符

### 问题4：随机数不随机
- 检查LFSR实现
- 验证不同时间生成的矩阵是否不同

---

## 七、测试记录表模板

| 测试用例 | 模式 | 输入数据 | 预期结果 | 实际结果 | 通过/失败 | 备注 |
|---------|------|---------|---------|---------|----------|------|
| 1.1 | INPUT | 2 3 4 5 6 7 8 9 | 存储2×3矩阵 | | | |
| 2.1 | GENERATE | 2 2 1 | 生成随机矩阵 | | | |
| 3.1 | DISPLAY | - | 显示矩阵 | | | |

---

## 八、OPERATION模式测试流程

### 8.1 准备工作

1. **前置条件**
   - 确保已通过INPUT或GENERATE模式存储了至少2个矩阵（用于双操作数运算）
   - 建议准备不同规格的矩阵用于测试各种运算类型
   - 推荐准备矩阵：
     - 2×2矩阵（用于加法、标量乘）
     - 2×3矩阵（用于转置、矩阵乘）
     - 3×2矩阵（用于矩阵乘）
     - 3×3矩阵（用于各种运算）

2. **硬件连接**（同前）

### 8.2 运算类型选择测试

#### 测试用例1：选择转置运算（T）

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `11`（OPERATION模式）
   - sw[4:2] = `000`（转置运算）
   - sw[5] = `0`（随机模式）或 `1`（手动模式）

2. **进入运算模式**
   - 按下按键V1（确认键）
   - 观察数码管：应显示 "T"（转置运算标识）

3. **查看矩阵列表**
   - 系统自动显示可用矩阵列表（UART输出）
   - 等待列表显示完成或按下V1继续

4. **选择操作数**
   - **随机模式**：系统自动选择
   - **手动模式**：通过UART输入矩阵ID（如：`0`）

5. **执行运算**
   - 按下V1确认选择
   - 观察LED：J2（BUSY）应点亮
   - 等待运算完成：K2（DONE）点亮3秒

6. **查看结果**
   - UART自动显示运算结果
   - 结果矩阵自动存储

**预期结果：**
- 转置运算成功完成
- 如果输入矩阵是m×n，结果矩阵是n×m
- 结果正确：C[j][i] = A[i][j]

---

#### 测试用例2：选择加法运算（A）

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `11`
   - sw[4:2] = `001`（加法运算）

2. **进入运算模式**
   - 按下V1
   - 观察数码管：应显示 "A"（加法运算标识）

3. **查看矩阵列表并选择操作数**
   - 系统显示可用矩阵列表
   - **手动模式**（sw[5]=1）：
     - 通过UART输入：`0 1`（矩阵A的ID和矩阵B的ID）
   - **随机模式**（sw[5]=0）：
     - 系统自动选择两个维度相同的矩阵

4. **执行运算**
   - 按下V1确认
   - 观察LED状态

5. **验证结果**
   - UART显示结果矩阵
   - 验证：C[i][j] = A[i][j] + B[i][j]

**预期结果：**
- 加法运算成功
- 结果矩阵维度与输入矩阵相同
- 元素值正确相加

---

#### 测试用例3：选择标量乘运算（b）

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `11`
   - sw[4:2] = `010`（标量乘运算）

2. **配置标量K（可选）**
   - 在进入运算模式前，通过UART发送：`CONFIG SCALAR 5`
   - 或使用默认值（默认K=3）

3. **进入运算模式**
   - 按下V1
   - 观察数码管：应显示 "b"（标量乘标识）

4. **选择操作数**
   - 手动模式：通过UART输入矩阵ID（如：`0`）
   - 随机模式：系统自动选择

5. **执行运算**
   - 按下V1确认
   - 等待运算完成

6. **验证结果**
   - UART显示结果矩阵
   - 验证：C[i][j] = K × A[i][j]

**预期结果：**
- 标量乘运算成功
- 结果矩阵维度与输入矩阵相同
- 每个元素都乘以标量K

---

#### 测试用例4：选择矩阵乘法运算（C）

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `11`
   - sw[4:2] = `011`（矩阵乘法）

2. **进入运算模式**
   - 按下V1
   - 观察数码管：应显示 "C"（矩阵乘标识）

3. **选择操作数**
   - **重要**：确保矩阵A的列数 = 矩阵B的行数
   - 手动模式：通过UART输入：`0 1`（例如：2×3矩阵和3×2矩阵）
   - 随机模式：系统自动选择兼容的矩阵

4. **执行运算**
   - 按下V1确认
   - 观察LED：J2（BUSY）点亮（矩阵乘需要更长时间）

5. **验证结果**
   - UART显示结果矩阵
   - 验证：如果A是m×n，B是n×p，则C是m×p
   - 验证：C[i][j] = Σ(A[i][k] × B[k][j])

**预期结果：**
- 矩阵乘法运算成功
- 结果矩阵维度正确（m×p）
- 计算结果正确

---

#### 测试用例5：选择卷积运算（J，如果实现）

**步骤：**
1. **设置拨码开关**
   - sw[1:0] = `11`
   - sw[4:2] = `100`（卷积运算）

2. **进入运算模式**
   - 按下V1
   - 观察数码管：应显示 "J"（卷积标识）

3. **选择操作数**
   - 确保卷积核（B）的尺寸 ≤ 被卷积矩阵（A）的尺寸
   - 手动模式：通过UART输入矩阵ID

4. **执行运算**
   - 按下V1确认
   - 等待运算完成

**预期结果：**
- 如果实现：卷积运算成功
- 如果未实现：系统报错（符合当前代码状态）

---

### 8.3 操作数选择测试

#### 测试用例6：手动模式选择操作数

**步骤：**
1. **准备矩阵**
   - 通过INPUT模式输入多个矩阵，记录它们的ID和规格

2. **进入运算模式**
   - sw[1:0] = `11`，sw[4:2] = `001`（加法）
   - sw[5] = `1`（手动模式）
   - 按下V1

3. **手动输入矩阵ID**
   - 系统显示矩阵列表后
   - 通过UART发送：`0 1`（矩阵A的ID和矩阵B的ID）
   - 按下V1确认

**预期结果：**
- 系统使用用户指定的矩阵进行运算
- 如果维度不匹配，系统报错

---

#### 测试用例7：随机模式选择操作数

**步骤：**
1. **准备矩阵**
   - 确保存储了多个兼容的矩阵

2. **进入运算模式**
   - sw[1:0] = `11`，sw[4:2] = `001`（加法）
   - sw[5] = `0`（随机模式）
   - 按下V1

3. **等待自动选择**
   - 系统自动从可用矩阵中选择两个维度相同的矩阵
   - 按下V1确认

**预期结果：**
- 系统自动选择合法的矩阵对
- 如果找不到兼容的矩阵，系统报错

---

#### 测试用例8：随机模式选择失败处理

**步骤：**
1. **准备不兼容的矩阵**
   - 只存储不同规格的矩阵（如只有2×2和3×3，没有相同规格的）

2. **进入加法运算**
   - sw[1:0] = `11`，sw[4:2] = `001`
   - sw[5] = `0`（随机模式）
   - 按下V1

3. **观察系统响应**

**预期结果：**
- 系统尝试选择后失败
- J3（ERROR）LED闪烁
- 倒计时显示
- 返回菜单或允许重新选择

---

### 8.4 维度兼容性测试

#### 测试用例9：加法运算 - 维度相同

**步骤：**
1. **准备两个2×2矩阵**
   - 通过INPUT模式输入：`2 2 1 2 3 4`（矩阵A）
   - 通过INPUT模式输入：`2 2 5 6 7 8`（矩阵B）

2. **执行加法**
   - sw[1:0] = `11`，sw[4:2] = `001`
   - 手动模式：输入 `0 1`
   - 按下V1执行

**预期结果：**
- 运算成功
- 结果矩阵：2×2，元素为对应位置相加

---

#### 测试用例10：加法运算 - 维度不匹配（错误）

**步骤：**
1. **准备不同维度矩阵**
   - 矩阵A：2×2
   - 矩阵B：3×3

2. **尝试执行加法**
   - sw[1:0] = `11`，sw[4:2] = `001`
   - 手动模式：输入 `0 1`

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 运算未执行

---

#### 测试用例11：矩阵乘法 - 维度兼容

**步骤：**
1. **准备兼容矩阵**
   - 矩阵A：2×3（A列数=3）
   - 矩阵B：3×2（B行数=3）
   - 满足：A列数 = B行数

2. **执行矩阵乘法**
   - sw[1:0] = `11`，sw[4:2] = `011`
   - 手动模式：输入 `0 1`
   - 按下V1执行

**预期结果：**
- 运算成功
- 结果矩阵：2×2（A行数 × B列数）

---

#### 测试用例12：矩阵乘法 - 维度不兼容（错误）

**步骤：**
1. **准备不兼容矩阵**
   - 矩阵A：2×2（A列数=2）
   - 矩阵B：3×3（B行数=3）
   - 不满足：A列数 ≠ B行数

2. **尝试执行矩阵乘法**
   - sw[1:0] = `11`，sw[4:2] = `011`
   - 手动模式：输入 `0 1`

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 运算未执行

---

### 8.5 运算结果验证测试

#### 测试用例13：转置运算结果验证

**步骤：**
1. **输入已知矩阵**
   - 输入：`2 3 1 2 3 4 5 6`
   - 矩阵A：
     ```
     1 2 3
     4 5 6
     ```

2. **执行转置**
   - sw[1:0] = `11`，sw[4:2] = `000`
   - 选择该矩阵，执行转置

3. **验证结果**
   - UART显示结果矩阵
   - 预期结果（3×2）：
     ```
     1 4
     2 5
     3 6
     ```

**预期结果：**
- 转置结果正确
- 维度从2×3变为3×2

---

#### 测试用例14：加法运算结果验证

**步骤：**
1. **输入两个矩阵**
   - 矩阵A：`2 2 1 2 3 4`
   - 矩阵B：`2 2 5 6 7 8`

2. **执行加法**
   - sw[1:0] = `11`，sw[4:2] = `001`
   - 选择矩阵A和B

3. **验证结果**
   - 预期结果：
     ```
     6  8
     10 12
     ```
   - 计算：1+5=6, 2+6=8, 3+7=10, 4+8=12

**预期结果：**
- 加法结果正确
- 每个元素对应位置相加

---

#### 测试用例15：标量乘运算结果验证

**步骤：**
1. **配置标量K**
   - 发送：`CONFIG SCALAR 3`

2. **输入矩阵**
   - 矩阵A：`2 2 1 2 3 4`

3. **执行标量乘**
   - sw[1:0] = `11`，sw[4:2] = `010`
   - 选择矩阵A

4. **验证结果**
   - 预期结果：
     ```
     3  6
     9  12
     ```
   - 计算：每个元素乘以3

**预期结果：**
- 标量乘结果正确
- 所有元素都乘以K

---

#### 测试用例16：矩阵乘法结果验证

**步骤：**
1. **输入两个矩阵**
   - 矩阵A（2×3）：`2 3 1 2 3 4 5 6`
   - 矩阵B（3×2）：`3 2 1 2 3 4 5 6`

2. **执行矩阵乘法**
   - sw[1:0] = `11`，sw[4:2] = `011`
   - 选择矩阵A和B

3. **验证结果**
   - 手动计算：
     - C[0][0] = 1×1 + 2×3 + 3×5 = 1+6+15 = 22
     - C[0][1] = 1×2 + 2×4 + 3×6 = 2+8+18 = 28
     - C[1][0] = 4×1 + 5×3 + 6×5 = 4+15+30 = 49
     - C[1][1] = 4×2 + 5×4 + 6×6 = 8+20+36 = 64
   - 预期结果（2×2）：
     ```
     22 28
     49 64
     ```

**预期结果：**
- 矩阵乘法结果正确
- 结果矩阵维度为2×2

---

### 8.6 运算结果存储测试

#### 测试用例17：运算结果自动存储

**步骤：**
1. **执行一次运算**
   - 任意运算类型，得到结果矩阵

2. **切换到DISPLAY模式**
   - sw[1:0] = `10`，按下V1
   - 浏览矩阵列表

**预期结果：**
- 运算结果矩阵已自动存储
- 可以通过DISPLAY模式查看
- 结果矩阵有独立的ID

---

#### 测试用例18：多次运算结果存储

**步骤：**
1. **连续执行多次运算**
   - 执行加法运算 → 结果1
   - 执行标量乘运算 → 结果2
   - 执行转置运算 → 结果3

2. **查看所有结果**
   - 切换到DISPLAY模式
   - 浏览所有矩阵

**预期结果：**
- 所有运算结果都正确存储
- 每个结果都有独立的ID
- 可以通过DISPLAY模式查看

---

### 8.7 运算流程完整性测试

#### 测试用例19：完整运算流程（加法）

**步骤：**
1. **准备阶段**
   - 输入矩阵A：`2 2 1 2 3 4`
   - 输入矩阵B：`2 2 5 6 7 8`

2. **选择运算类型**
   - sw[1:0] = `11`，sw[4:2] = `001`（加法）
   - 按下V1进入运算模式

3. **查看矩阵列表**
   - 等待UART显示可用矩阵列表
   - 或按下V1跳过

4. **选择操作数**
   - sw[5] = `1`（手动模式）
   - 通过UART输入：`0 1`
   - 按下V1确认

5. **执行运算**
   - 观察LED：J2（BUSY）点亮
   - 等待运算完成：K2（DONE）点亮

6. **查看结果**
   - UART自动显示结果矩阵
   - 验证结果正确性

7. **继续或返回**
   - 按下V1：继续当前运算类型（重新选择操作数）
   - 按下R11：切换到其他运算类型
   - 按下R17：返回主菜单

**预期结果：**
- 完整流程顺畅执行
- 所有步骤响应正确
- 结果正确显示和存储

---

#### 测试用例20：运算后继续当前类型

**步骤：**
1. **执行一次运算**
   - 完成加法运算并查看结果

2. **继续当前运算**
   - 在结果显示界面，按下V1

**预期结果：**
- 返回操作数选择界面
- 可以重新选择矩阵进行相同类型的运算
- 不需要重新选择运算类型

---

#### 测试用例21：运算后切换运算类型

**步骤：**
1. **执行一次运算**
   - 完成加法运算并查看结果

2. **切换运算类型**
   - 在结果显示界面，按下R11（下一个键）
   - 或返回菜单重新选择运算类型

**预期结果：**
- 返回运算类型选择界面
   - 或返回主菜单
- 可以重新选择不同的运算类型

---

### 8.8 边界情况测试

#### 测试用例22：单矩阵运算（转置、标量乘）

**步骤：**
1. **准备单个矩阵**
   - 输入：`3 3 1 2 3 4 5 6 7 8 9`

2. **执行转置**
   - sw[1:0] = `11`，sw[4:2] = `000`
   - 选择该矩阵

**预期结果：**
- 转置成功（单操作数运算）
- 结果正确

---

#### 测试用例23：最大矩阵运算（5×5）

**步骤：**
1. **准备5×5矩阵**
   - 输入或生成5×5矩阵

2. **执行运算**
   - 选择转置或标量乘

**预期结果：**
- 运算成功
- 结果矩阵正确（25个元素）

---

#### 测试用例24：运算结果溢出处理

**步骤：**
1. **准备大值矩阵**
   - 输入：`2 2 100 100 100 100`（如果范围允许）

2. **执行标量乘**
   - 配置K=10
   - 执行标量乘

**预期结果：**
- 系统应处理溢出（饱和到127或-128）
- 或报错（如果超出范围）

---

### 8.9 错误处理测试

#### 测试用例25：选择不存在的矩阵ID

**步骤：**
1. **进入运算模式**
   - sw[1:0] = `11`，sw[4:2] = `001`
   - sw[5] = `1`（手动模式）

2. **输入无效ID**
   - 通过UART输入：`99 99`（不存在的矩阵ID）

**预期结果：**
- J3（ERROR）LED闪烁
- 倒计时显示
- 允许重新选择

---

#### 测试用例26：运算过程中断电恢复（如果支持）

**步骤：**
1. **开始运算**
   - 执行矩阵乘法（耗时较长）

2. **观察系统状态**
   - 检查系统是否能正确处理中断

**预期结果：**
- 根据实现，可能：
  - 运算中断，返回错误状态
  - 或运算完成后恢复

---

## 九、配置命令详细测试

### 9.1 CONFIG RANGE测试

#### 测试用例1：配置元素范围

**步骤：**
1. **发送配置命令**
   - 在任意模式下，通过UART发送：`CONFIG RANGE 0 15`
   - 点击"发送"

2. **验证配置生效**
   - 切换到INPUT模式
   - 输入矩阵：`2 2 10 11 12 13`
   - 观察是否成功存储

**预期结果：**
- 配置成功（可能无显式提示）
- 后续INPUT/GENERATE模式使用新范围[0,15]
- 元素值10-13在范围内，成功存储

---

#### 测试用例2：配置负数范围

**步骤：**
1. **发送配置命令**
   - 发送：`CONFIG RANGE -5 5`

2. **验证配置**
   - 切换到INPUT模式
   - 尝试输入负数元素（如果支持）

**预期结果：**
- 配置成功
- 系统接受[-5,5]范围内的值

---

#### 测试用例3：配置无效范围（min > max）

**步骤：**
1. **发送无效配置**
   - 发送：`CONFIG RANGE 10 5`（min > max）

**预期结果：**
- 系统应拒绝配置
- 可能报错或忽略

---

### 9.2 CONFIG MAX测试

#### 测试用例4：配置每种规格最大数量

**步骤：**
1. **发送配置命令**
   - 发送：`CONFIG MAX 3`
   - 含义：每种规格最多存储3个矩阵

2. **验证配置**
   - 切换到INPUT模式
   - 连续输入4个2×2矩阵
   - 观察存储情况

**预期结果：**
- 前3个矩阵正常存储
- 第4个矩阵覆盖第1个（FIFO覆盖策略）

---

#### 测试用例5：配置最大数量边界值

**步骤：**
1. **配置最小值**
   - 发送：`CONFIG MAX 1`

2. **输入同规格矩阵**
   - 输入2个2×2矩阵

**预期结果：**
- 第1个矩阵存储
- 第2个矩阵覆盖第1个

---

### 9.3 CONFIG COUNT测试

#### 测试用例6：配置错误倒计时时间

**步骤：**
1. **发送配置命令**
   - 发送：`CONFIG COUNT 15`
   - 含义：错误倒计时15秒

2. **触发错误**
   - 切换到INPUT模式
   - 输入维度超范围的矩阵：`6 3 1 2 3...`

3. **观察倒计时**
   - 数码管应显示15秒倒计时
   - 倒计时结束后返回菜单

**预期结果：**
- 倒计时显示15秒（而非默认10秒）
- 倒计时结束后自动返回菜单

---

#### 测试用例7：配置倒计时边界值

**步骤：**
1. **配置最小值**
   - 发送：`CONFIG COUNT 1`

2. **触发错误**
   - 输入无效数据

**预期结果：**
- 倒计时显示1秒
- 快速返回菜单

---

### 9.4 CONFIG SCALAR测试

#### 测试用例8：配置标量K

**步骤：**
1. **发送配置命令**
   - 发送：`CONFIG SCALAR 5`
   - 含义：标量乘的K值设为5

2. **验证配置**
   - 切换到OPERATION模式
   - 选择标量乘运算
   - 执行运算

**预期结果：**
- 标量乘使用K=5
- 结果矩阵每个元素乘以5

---

#### 测试用例9：配置负数标量K

**步骤：**
1. **发送配置命令**
   - 发送：`CONFIG SCALAR -3`

2. **执行标量乘**
   - 选择矩阵，执行标量乘

**预期结果：**
- 标量乘使用K=-3
   - 结果矩阵每个元素乘以-3（可能产生负数）

---

#### 测试用例10：配置标量K边界值

**步骤：**
1. **配置最大值**
   - 发送：`CONFIG SCALAR 127`

2. **配置最小值**
   - 发送：`CONFIG SCALAR -128`

**预期结果：**
- 配置成功
- 标量乘使用配置的值

---

### 9.5 CONFIG SHOW测试

#### 测试用例11：显示当前配置

**步骤：**
1. **发送显示命令**
   - 发送：`CONFIG SHOW`

2. **观察输出**
   - UART应显示当前所有配置参数

**预期结果：**
- 显示元素范围、最大数量、倒计时、标量K等
- 格式清晰易读

---

## 十、错误处理综合测试

### 10.1 输入错误处理

#### 测试用例1：维度错误序列

**步骤：**
1. **测试各种维度错误**
   - m=0（小于1）
   - m=6（大于5）
   - n=0（小于1）
   - n=6（大于5）

2. **观察错误处理**
   - 每次错误后观察LED和倒计时

**预期结果：**
- 所有维度错误都被正确检测
- J3（ERROR）LED闪烁
- 倒计时显示
- 倒计时结束后返回菜单

---

#### 测试用例2：元素值错误序列

**步骤：**
1. **配置范围[0,9]**
   - 发送：`CONFIG RANGE 0 9`

2. **测试各种元素值错误**
   - 输入元素值10（超出上限）
   - 输入元素值-1（低于下限，如果支持）

**预期结果：**
- 所有元素值错误都被正确检测
- 错误提示及时

---

### 10.2 运算错误处理

#### 测试用例3：维度不匹配错误

**步骤：**
1. **准备不兼容矩阵**
   - 矩阵A：2×2
   - 矩阵B：3×3

2. **尝试加法运算**
   - 选择矩阵A和B
   - 执行加法

**预期结果：**
- 系统检测到维度不匹配
- J3（ERROR）LED闪烁
- 倒计时显示
- 运算未执行

---

#### 测试用例4：矩阵乘法维度不兼容

**步骤：**
1. **准备不兼容矩阵**
   - 矩阵A：2×2（A列数=2）
   - 矩阵B：3×3（B行数=3）

2. **尝试矩阵乘法**
   - 选择矩阵A和B
   - 执行矩阵乘法

**预期结果：**
- 系统检测到A列数 ≠ B行数
- 错误提示
- 运算未执行

---

### 10.3 存储错误处理

#### 测试用例5：存储空间不足（如果实现）

**步骤：**
1. **填满存储空间**
   - 输入大量不同规格的矩阵

2. **尝试继续输入**
   - 观察系统响应

**预期结果：**
- 根据实现，可能：
  - 覆盖旧矩阵
  - 或报错提示存储空间不足

---

## 十一、LED和数码管综合测试

### 11.1 LED状态指示测试

#### 测试用例1：正常操作LED状态

**步骤：**
1. **执行正常操作序列**
   - INPUT模式输入矩阵
   - GENERATE模式生成矩阵
   - OPERATION模式执行运算

2. **观察LED状态**

**预期结果：**
- **正常状态**：
  - J3（ERROR）熄灭
  - J2（BUSY）在运算/生成时点亮
  - K2（DONE）在完成时点亮3秒后熄灭

---

#### 测试用例2：错误状态LED指示

**步骤：**
1. **触发各种错误**
   - 维度超范围
   - 元素值超范围
   - 维度不匹配

2. **观察LED状态**

**预期结果：**
- **错误状态**：
  - J3（ERROR）闪烁（2Hz频率）
  - J2（BUSY）熄灭
  - K2（DONE）熄灭

---

### 11.2 数码管显示测试

#### 测试用例3：模式指示

**步骤：**
1. **切换不同模式**
   - INPUT模式：观察显示 "I"
   - GENERATE模式：观察显示 "G"
   - DISPLAY模式：观察显示矩阵编号
   - OPERATION模式：观察显示运算类型（T/A/b/C/J）

**预期结果：**
- 每种模式都有清晰的标识
- 显示稳定，无闪烁

---

#### 测试用例4：倒计时显示

**步骤：**
1. **触发错误**
   - 输入无效数据

2. **观察倒计时**
   - 数码管应显示倒计时数值
   - 倒计时应递减

**预期结果：**
- 倒计时显示清晰（如：15, 14, 13...）
- 倒计时结束后返回菜单

---

#### 测试用例5：矩阵编号显示

**步骤：**
1. **在DISPLAY模式下**
   - 浏览不同矩阵

2. **观察数码管**
   - 应显示当前矩阵编号（0-9）

**预期结果：**
- 矩阵编号显示正确
- 切换矩阵时编号更新及时

---

## 十二、UART通信稳定性测试

### 12.1 连续操作测试

#### 测试用例1：快速连续输入

**步骤：**
1. **快速连续发送多个矩阵**
   - 不等待前一个完成，连续发送

2. **观察系统响应**

**预期结果：**
- 系统能正确处理所有输入
- 无数据丢失
- 无通信错误

---

#### 测试用例2：长时间运行测试

**步骤：**
1. **执行长时间操作序列**
   - 输入多个矩阵
   - 生成多个矩阵
   - 执行多次运算
   - 显示多个矩阵

2. **观察系统稳定性**

**预期结果：**
- 系统稳定运行
- 无异常复位
- 所有功能正常

---

### 12.2 数据完整性测试

#### 测试用例3：大数据量传输

**步骤：**
1. **输入最大矩阵**
   - 输入5×5矩阵（25个元素）

2. **验证数据完整性**
   - 切换到DISPLAY模式查看

**预期结果：**
- 所有25个元素都正确存储
- 显示时数据完整

---

#### 测试用例4：特殊字符处理

**步骤：**
1. **测试特殊输入**
   - 测试空格、换行符等特殊字符的处理

**预期结果：**
- 系统正确处理特殊字符
- 不影响数据解析

---

## 十三、综合场景测试

### 13.1 完整工作流程测试

#### 测试用例1：完整用户场景

**步骤：**
1. **配置系统**
   - 发送：`CONFIG RANGE 0 9`
   - 发送：`CONFIG MAX 2`
   - 发送：`CONFIG SCALAR 3`

2. **输入矩阵**
   - INPUT模式：输入2×2矩阵A
   - INPUT模式：输入2×2矩阵B

3. **生成矩阵**
   - GENERATE模式：生成3×3矩阵C

4. **查看矩阵**
   - DISPLAY模式：浏览所有矩阵

5. **执行运算**
   - OPERATION模式：执行矩阵A和B的加法
   - 查看结果

6. **继续运算**
   - 执行标量乘运算
   - 查看结果

**预期结果：**
- 所有步骤顺畅执行
- 所有功能正常工作
- 结果正确

---

#### 测试用例2：错误恢复场景

**步骤：**
1. **触发错误**
   - 输入无效数据，触发错误

2. **等待错误处理**
   - 观察倒计时
   - 等待自动返回菜单

3. **继续正常操作**
   - 输入有效数据
   - 验证系统恢复正常

**预期结果：**
- 错误处理后系统恢复正常
- 可以继续正常操作

---

## 十四、性能测试

### 14.1 运算速度测试

#### 测试用例1：各种运算耗时

**步骤：**
1. **测试转置速度**
   - 执行5×5矩阵转置
   - 记录从开始到完成的时间

2. **测试加法速度**
   - 执行5×5矩阵加法
   - 记录时间

3. **测试矩阵乘法速度**
   - 执行5×5矩阵乘法
   - 记录时间（应比转置和加法慢）

**预期结果：**
- 所有运算在合理时间内完成
- 矩阵乘法耗时最长（符合预期）

---

### 14.2 存储容量测试

#### 测试用例2：存储容量极限

**步骤：**
1. **填满存储空间**
   - 输入/生成矩阵直到存储空间满

2. **验证存储管理**
   - 观察覆盖策略
   - 验证矩阵列表显示

**预期结果：**
- 存储管理正确
- 覆盖策略符合设计

---

## 十五、测试记录表完整版

| 测试用例 | 模式 | 输入数据/操作 | 预期结果 | 实际结果 | 通过/失败 | 备注 |
|---------|------|-------------|---------|---------|----------|------|
| 1.1 | INPUT | 2 3 4 5 6 7 8 9 | 存储2×3矩阵 | | | |
| 2.1 | GENERATE | 2 2 1 | 生成随机矩阵 | | | |
| 3.1 | DISPLAY | - | 显示矩阵 | | | |
| 8.1 | OPERATION | sw[4:2]=000 | 转置运算 | | | |
| 8.2 | OPERATION | sw[4:2]=001 | 加法运算 | | | |
| 8.3 | OPERATION | sw[4:2]=010 | 标量乘运算 | | | |
| 8.4 | OPERATION | sw[4:2]=011 | 矩阵乘法 | | | |
| 9.1 | CONFIG | CONFIG RANGE 0 15 | 配置范围 | | | |
| 9.4 | CONFIG | CONFIG SCALAR 5 | 配置标量K | | | |
| 10.1 | ERROR | 6 3 ... | 维度错误 | | | |
| 11.1 | LED | 正常操作 | LED指示正确 | | | |

---

**文档版本：** v2.0  
**最后更新：** 2024年  
**适用项目：** CS207 FPGA矩阵计算器  
**新增内容：** OPERATION模式、配置命令、错误处理、综合测试

